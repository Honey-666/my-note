# MySQL高级

> **sql查询分组时是将一组中多个值合成一个返回，所以查询时不要用* ，要给他指定查询内容**

### MySQL逻辑架构

和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用，并发挥良好作用。<font color='red'>主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。</font>这种架构可以根据业务的需求和实际需要选择合适的存储引擎。

![image-20210227090630961](typora-user-images\image-20210227090630961.png)

上图解释：

1. 连接层（connectors）
   1. 处理和检查MySQL的链接
   2. 主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限
2. 服务层
   1.  Management Serveices & Utilities： 系统管理和控制工具
   2. 对sql进行判断，是crud的哪一个
   3. 解析（sql interface）
      1. SQL命令传递到解析器的时候会被解析器验证和解析。
   4. 优化器（parser）
      1. SQL语句在查询之前会使用查询优化器对查询进行优化。 
      2. 优化器来决定先投影还是先过滤。
      3. 优化后生成sql树
   5. 缓存（cache）
      1. 如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。
      2. 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等
3. 引擎层
   1. 根据sql需要的操作通过io的方式去存储层读文件
   2. 存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB
4. 存储层
   1. 数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。

### 查询流程说明

![image-20210227091749061](typora-user-images\image-20210227091749061.png)

首先，mysql的查询流程大致是：

​		<font color='red'>mysql客户端通过协议与mysql服务器建连接，发送查询语句，先检查查询缓存，如果命中，直接返回结果</font>，否则进行语句解析,也就是说，在解析查询之前，服务器会先访问查询缓存(query cache)——它存储SELECT语句以及相应的查询结果集。如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。

​		语法解析器和预处理：首先mysql通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”。<font color='red'>mysql解析器将使用mysql语法规则验证和解析查询</font>；预处理器则根据一些mysql规则进一步检查解析树是否合法。

​		当解析树被认为是合法的了，<font color='red'>查询优化器将其转化成执行计划</font>。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。

### sql语法顺序

机读顺序from->JOIN->ON->where->GROUP BY->HAVING->SELECT->ORDER BY->LIMIT

![image-20210227093652810](typora-user-images\image-20210227093652810.png)

### MySQL存储引擎

查看存储引擎：show engines;

#### 各引擎简介

1. **InnoDB存储引擎（重要，用户自定义表默认引擎）**

   InnoDB是MySQL的默认事务型引擎，它被设计用来<font color='red'>处理大量的短期(short-lived)事务</font>。除非有非常特别的原因需要使用其他的存储引擎，否则<font color='red'>应该优先考虑InnoDB引擎。</font>

2. **MyISAM存储引擎（重要，mysql系统表默认引擎）**

   MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但<font color='red'>MyISAM不支持事务和行级锁</font>，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。

3. Archive引擎

   <font color='red'>Archive档案存储引擎只支持INSERT和SELECT操作</font>，在MySQL5.1之前不支持索引。

   Archive表适合日志和数据采集类应用。

   根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。

4. Blackhole引擎

   <font color='red'>Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。</font>但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。 

5. CSV引擎 

   <font color='red'>CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。</font>

   CSV引擎可以作为一种数据交换的机制，非常有用。

   CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。

6. Memory引擎

   如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。Memory表至少比MyISAM表要快一个数量级。

7. Federated引擎

   Federated引擎<font color='red'>是访问其他MySQL服务器的一个代理</font>，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。

#### MyISAM和InnoDB的区别(重点)

| **对比项**         | **MyISAM**                                                | **InnoDB**                                                   |
| ------------------ | --------------------------------------------------------- | ------------------------------------------------------------ |
| **外键**           | 不支持                                                    | 支持                                                         |
| **事务**           | 不支持                                                    | 支持                                                         |
| **行表锁**         | 表锁，即使操作一条记录也会锁住整个表   不适合高并发的操作 | 行锁,操作时只锁某一行，不对其它行有影响   适合高并发的操作   |
| **缓存**           | 只缓存索引，不缓存真实数据                                | 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 |
| **关注点**         | 节省资源、消耗少、简单业务                                | 并发写、事务、更大资源                                       |
| **默认安装**       | Y                                                         | Y                                                            |
| **用户表默认使用** | N                                                         | Y                                                            |
| **自带系统表使用** | Y                                                         | N                                                            |

> **mysql8.0以后默认引擎都是用innodb**

### 索引

MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。
可以得到索引的本质：<font color='red'>索引是数据结构。</font>

索引的目的在于<font color='red'>提高查询效率</font>，可以类比字典

<font color='red'>你可以简单理解为“排好序的快速查找数据结构”。</font>

但都创建一个指针来存储索引，索引也是需要占内存的，不是越多越好也不是越少越好

​	一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往<font color='red'>以索引文件的形式存储的磁盘上</font>

#### 索引优劣势

优势：

1. 类似大学图书馆建书目索引，<font color='red'>提高数据检索的效率</font>，降低数据库的IO成本。

2. 通过索引列对数据进行排序或分组，<font color='red'>降低数据排序的成本</font>，降低了CPU的消耗。

劣势：

1. 虽然索引大大提高了查询速度，同时却会<font color='red'>降低更新表的速度</font>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息

2. 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以<font color='red'>索引列也是要占用空间的</font>

#### BTree（也叫B-Tree）

![image-20210227112759804](typora-user-images\image-20210227112759804.png)

【初始化介绍】 
一颗b树，浅蓝色的块我们称之为一个磁盘块(innodb默认16kb一个磁盘块)，可以看到每个磁盘块包含几个<font color='red'>数据项（深蓝色所示）、指向关键字具体信息的指针（红色）和指向其他磁盘块的指针（黄色所示）</font>
如磁盘块1包含数据项17和35，包含指针P1、P2、P3，
P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。

【查找过程】
如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。

真实的情况是，3层的b树可以表示上百万的数据，如果上百万的数据查找<font color='red'>只需要三次IO</font>，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

#### B+Tree索引

![image-20210227112848858](typora-user-images\image-20210227112848858.png)

B+Tree与B-Tree 的区别

　1）B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；<font color='red'>B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。</font>
　 2）在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，而在实际应用中却是B+树的性能要好些。因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是减少磁盘访问次数。尽管B+树找到一个记录所需的比较次数要比B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中B+树的性能可能还会好些，而且B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用B+树的缘故。 
　
思考：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？ 
1) **B+树的磁盘读写代价更低** 
　　B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 
2) **B+树的查询效率更加稳定** 
　　由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

#### 聚簇索引与非聚簇索引

**聚簇索引（主键索引）**：将索引指向对应一行的值，找到索引也就找到了数据

**非聚簇索引（二级索引）**：将数据存储于索引分开结构，二级索引中存的是对应的列和一级索引主键值，所以总是要经过两次才能查询到

澄清一个概念：<font color='red'>innodb中，非聚簇索引又称辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。</font>

![image-20210227122312078](typora-user-images\image-20210227122312078.png)

InnoDB使用聚簇索引，将**主键组织到一棵B+树**中，而**行数据就储存在叶子节点**上，若使用"where id = 14"这样的条件查找主键，则**按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据**。

若**对Name列进行条件搜索，则需要两个步骤**：**第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键**。第二步**使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据**。（**重点在于通过其他键需要建立辅助索引**）

聚簇索引的好处：

- 由于**行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问**，不必访问磁盘。这样**主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回**了，**如果按照主键Id来组织数据，获得数据更快**。

- 聚簇索引适合用在排序的场合，非聚簇索引不适合

- 取出一定范围数据的时候，使用用聚簇索引

- 二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据

聚簇索引的限制：

- 对于mysql数据库目前只有innodb数据引擎支持聚簇索引，而Myisam并不支持聚簇索引。
- 由于数据物理存储排序方式只能有一种，所以每个Mysql的表只能有一个聚簇索引。
  - 一般情况下就是该表的主键。
  - 如果没有primary key,会以(not null unique key)非空的唯一索引保存数据
  - 内部自己生成一个字段保存数据
- 为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序非空的字段，而不建议用无序的id，比如uuid这种。

#### 索引的分类

1. 主键索引：设定为主键后数据库会自动建立索引，innodb为聚簇索引
2. 单值索引：即一个索引只包含单个列，一个表可以有多个单列索引
3. 唯一索引：索引列的值必须唯一，但允许有空值
4. 复合索引：即一个索引包含多个列

#### 索引使用场景

哪些情况需要创建索引：

- 主键自动建立唯一索引
- 频繁作为查询条件的字段应该创建索引
- 查询中与其它表关联的字段，外键关系建立索引
- 单键/组合索引的选择问题， 组合索引性价比更高
- 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
- 查询中统计或者分组字段

哪些情况不要创建索引：

- 表记录太少

- 经常增删改的表或者字段。

  Why：提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件

- Where条件里用不到的字段不创建索引

- 过滤性不好的不适合建索引

### 索引优化

在查询sql语句前加explain就能查看当前sql的执行效率

**可以查询：**

- <font color='red'>表的读取顺序</font>
- 那些索引可以使用
- 数据读取操作的操作类型
- <font color='red'>那些索引被实际使用</font>
- 表之间的引用
- <font color='red'>每张表有多少行被物理查询</font>

> **标红的是后续注意要优化的**

![image-20210227143059851](typora-user-images\image-20210227143059851.png)

#### id字段（重要）

<font color='red'>每个id号码，表示一趟独立的查询。一个sql 的查询趟数越少越好。</font>

- id相同，执行顺序由上至下
- id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
- id既有相同又有不同 先执行大的，然后再按顺序执行相同的

#### select_type(不会用于优化，了解)

查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询

| `SIMPLE`               | 简单的 SELECT(没有 使用UNION或者 子查询（PS：单表查询）)     |
| ---------------------- | ------------------------------------------------------------ |
| `PRIMARY`              | 最外层的Select 作为primary 查询。(PS:含有子查询的情况,但是并不复杂)案例1 |
| `DERIVED`              | 在from 查询语句中的（派生，嵌套很多）子查询.(PS:递归操作这些子查询) |
| `SUBQUERY`             | 在SELECT或WHERE列表中包含了子查询。案例2                     |
| `DEPENDENT SUBQUERY`   | 第一个查询是子查询，依赖于外部查询（相关查询）。案例3        |
| `MATERIALIZED`         | 在非相关子查询中 并且需要进行物化时会出现MATERIALIZED关键词。案例4 |
| `UNCACHEABLE SUBQUERY` | 子查询结果(系统变量)不能被缓存， 而且必须重写（分析）外部查询的每一行。案例5 |
| `UNION`                | 若第二个SELECT出现在UNION之后，则被标记为UNION。案例6 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED |
| `UNION RESULT`         | 结果集是通过union 而来的。案例6                              |

#### table

- 显示这一行的数据是关于哪张表的

#### partitions

- 代表分区表中的命中情况，非分区表，该项为null

#### type(重要)

type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是： 

null>system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > <font color='#FFD700'>range</font> ><font color="orange"> index</font> > <font color="red">ALL </font>

常见：system > const > eq_ref > ref > <font color='#FFD700'>range</font> ><font color="orange"> index</font> > <font color="red">ALL </font>

> **带颜色的要考虑优化**

**一般来说，得保证查询至少达到range级别，最好能达到ref。**

 **null**:   MySQL不访问任何表或索引，直接返回结果（**也就是不走索引，走缓存了**）

**system**：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计。

**const**：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量。（select * from t1 where t1.id=1）

**eq_ref**：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。（select * from t1,t2 where t1.id=t2.id）

**ref**:  使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中

**range**：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的where语句中出现了between、<、>、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。（select * from t1 where t1.id<10）

**index**：出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组。（explain select id from t1）

**all**：Full Table Scan，将遍历全表以找到匹配的行。（explain select * from t1）

**index_merge**：在查询过程中需要多个索引组合使用，通常出现在有 or 的关键字的sql中。

**ref_or_null**：对于某个字段既需要关联条件，也需要null值得情况下。查询优化器会选择用ref_or_null连接查询。

**index_subquery**：利用索引来关联子查询，不再全表扫描。

**unique_subquery**：该联接类型类似于index_subquery。 子查询中的唯一索引。



#### possible_keys

显示可能应用在这张表中的索引，一个或多个。
查询涉及到的字段上若存在索引，则该索引将被列出，**但不一定被查询实际使用**

####  key(优化重要指标)

实际使用的索引。如果为NULL，则没有使用索引。

**查询中若使用了覆盖索引，则该索引和查询的select字段重叠**

**覆盖索引：就是我们查询出来的结果能够覆盖或包含我们查询的列**

#### key_len(重要)

表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 

key_len字段能够帮你检查是否充分的利用上了索引。

如何计算

1. 先看索引上字段的类型+长度比如 int=4 ;  varchar(20) =20 ; char(20) =20  
2. 如果是varchar或者char这种字符串字段，视字符集要乘不同的值，比如utf-8  要乘 3,GBK要乘2，
3. varchar这种动态字符串要加2个字节
4. 允许为空的字段要加1个字节  

例：

```sql
#分析：age是int类型，站4 可以为空站1  4+1        name 字符集是utf8要乘3 数据类型varchar是20可以为空加一，varchar要单独加2  20*3+1+2
EXPLAIN SELECT * FROM t_emp where age>70 AND NAME= 'aaa'
```

> **索引字段最好不要为NULL，因为NULL让统计更加复杂，并且需要额外一个字节的存储空间。**

#### ref

显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值

#### rows(优化参考，值是估算的)

rows列显示MySQL认为它执行查询时必须检查的行数。**越少越好**

表示本次查询需要筛选的记录条数，越少越好（但是是估算值，可能与实际执行有偏差）

#### filtered

这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数

一般和上面的**rows**一起使用

#### extra(优化重要指标)

包含不适合在其他列中显示但十分重要的额外信息

别的地方不适合显示的优化信息显示在extra字段下

**三个需要考虑优化的:**

- <font color="red">**Using filesort**</font>：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。
  MySQL中无法利用索引完成的排序操作称为“文件排序”这类SQL语句性能极差，需要进行优化。在一个非索引列上进行了order by，就会触发filesort，常见的优化方案是，在order by的列上添加索引，避免每次查询都全量排序(只查询索引列的值)。
- <font color="red">**Using temporary**</font>：使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。
- <font color="red">**using join buffer**</font>：使用了连接缓存，非主键关联

**其他不用优化的：**

- **USING index**：利用索引进行了排序或分组。表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！（EXPLAIN select * from t_emp where age=30 ORDER BY name）
  如果同时出现using where，表明索引被用来执行索引键值的查找;
  如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。
- **Using where**：表明使用了where过滤
- **impossible where**：where子句的值总是false，不能用来获取任何元组。（EXPLAIN select * from t_emp where false;）
- **select tables optimized away**：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者
  对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。

### 单表优化

####  索引优化原则

1. 不在索引列上做任何操作（**计算、函数、(自动or手动)类型转换**），会导致索引失效而转向全表扫描
2. **like以通配符开头**('%abc...')mysql索引失效会变成全表扫描的操作
3. mysql 在使用**不等于(!=或者<>)**的时候无法使用索引会导致全表扫描
4. **is not null** 也无法使用索引，但是is null是可以使用索引的
5. **字符串不加单引号**索引失效

#### 组合索引原则

1. 全值匹配我最爱
2. 符合最左原则：不跳过索引中的列。
   1. 创建复合索引时过滤性强的和经常用到的放在前面（**复合索引必须符合最左原则，根据创建的索引从最左边的匹配，如果匹配不上就直接断开**）
3. 如果where条件中是OR关系, 并且or两边的条件字段不在同一个索引 索引失效
4. 如果出现范围查询，那么范围查询后面的字段用不上索引(使用范围查询的字段可以用)

### 关联查询优化

> **mysql5.6以后内连接查询始终会使用小表驱动大表，使数据查询的时候提高性能**
>
> **总结：尽量给大表创建索引，然后使用小表驱动大表，如果必须使用大表驱动小表，那么也给小表创建一个索引**
>
> **给被驱动表创建索引**

1. 保证被驱动表的join字段已经创建了索引
2. left/right join 时，选择小表作为驱动表，大表作为被驱动表。
3. inner join 时，mysql会自己帮你把小结果集的表选为驱动表。(5.6已经优化掉了，5.5需要手动编写)
4. 子查询尽量不要放在被驱动表，有可能使用不到索引。
5. 能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)

### 子查询优化

尽量不要使用not in  或者 not exists

尽量不要使用子查询

### 排序优化

以下三种情况不走索引：

1. 无过滤，不索引
2. 顺序错，不索引（就是order by的字段跟创建的索引顺序不一致）
3. 方向反，不索引（排序字段一个升序一个降序）

> **结论：**
> 			**1、如果筛选条件过滤剩余的数据非常少，可以对筛选条件的字段创建索引**
> 			**2、如果筛选条件的数据剩余的仍然非常多，需要给排序的字段创建索引**
> 		**注意事项：order by 不使用limit或者where条件（where条件要匹配最左策略）过滤的话不会使用索引，group by 可以直接使用索引**

结论： **当范围条件和group by 或者 order by  的字段出现二选一时 ，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。**

### 分组优化

group by 使用索引的原则几乎跟order by一致 ，唯一区别是**groupby 即使没有过滤条件用到索引，也可以直接使用索引。**

只要对分组的列创建索引

###  覆盖索引

什么是覆盖索引？
简单说就是，select 到 from 之间查询的列 <=使用的索引列+主键

也就是要查询的字段<=使用的索引字段+主键或者说**要查询的字段都有索引，就是索引覆盖**

**例：**

```sql
ALTER TABLE emp add INDEX idx_age(age);
#不会走索引，因为查询字段是所有，而有索引的是age和id
EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE age<>30;
#会走索引
EXPLAIN SELECT SQL_NO_CACHE age FROM emp WHERE age<>30;
#不会走索引，name没有索引,并且查询中也没有查询name字段
EXPLAIN SELECT SQL_NO_CACHE id,age FROM emp WHERE NAME LIKE '%abc';
```

## 索引性能

如果列已建立索引，则索引会自动分配最大可能大小，以便索引中的每个节点都有足够的空间来存储任何可能的值。在搜索索引时，MySQL一次以特定字节大小的块加载节点。大节点意味着每次读取的节点更少，这意味着搜索索引需要更长的时间。