# 分布式事务

### 本地事务与分布式事务

**事务提供一种“要么什么都不做，要么做全套（All or Nothing）机制**。

**反向补偿：**在操作之前先记录一次，如果执行中有错误发生那么全部恢复到记录的状态

* **TC(Transaction Coordinator)事务协调者**：steata充当协调者

- **TM(Transaction Manager)**: 相当于GlobalTransactional注解

- **RM(Resource Manager)资源管理者**:@Transactional注解

#### 事务的四大特性

> **数据库的四大特性（ACID）：**
>
> **1.原子性（Atomicity）**
>
> 　　原子性是指事务包含的**所有操作要么全部成功，要么全部失败回滚**。失败回滚的操作事务，将不能对事务有任何影响。
>
> **2. 一致性（Consistency）**
>
> 　　一致性是指事务必须使数据库从一个**一致性状态**变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
>
> 　　例如：A和B进行转账操作，A有200块钱，B有300块钱；当A转了100块钱给B之后，他们2个人的总额还是500块钱，不会改变。
>
> **3. 隔离性（Isolation）**
>
> 　　隔离性是指当多个用户并发访问数据库时，比如**同时访问一张表**，数据库每一个用户开启的事务，不能被其他事务所做的操作干扰(也就是事务之间的隔离)，多个并发事务之间，应当相互隔离。
> 　　例如：同时有T1和T2两个并发事务，从T1角度来看，T2要不在T1执行之前就已经结束，要么在T1执行完成后才开始。将多个事务隔离开，每个事务都不能访问到其他事务操作过程中的状态；就好比上锁操作，只有一个事务做完了，另外一个事务才能执行。
>
> **4. 持久性（Durability）**
>
> 　　持久性是指事务的操作，一旦提交，对于数据库中数据的改变是永久性的，即使数据库发生故障也不能丢失已提交事务所完成的改变。

本地事务：**基于单个服务单一数据库资源访问的事务，被称为本地事务(Local Transaction)**

* 本地事务有这么几个特征:
  *   一次事务只连接一个支持事务的数据库（一般来说都是关系型数据库）
  *   事务的执行结果保证ACID
  *  会用到数据库锁

**解决多微服务，多数据源的事务回滚的方式就是使用分布式事务**

### CAP定理

- 一致性（**C**onsistency）
- 可用性（**A**vailability）
- 分区容错性（**P**artition tolerance）

**C (一致性Consistency)**：指数据在多个副本之间能够保持一致的特性（严格的一致性）在分布式系统中的所有数据备份，在同一时刻是否同样的值。（所有节点在同一时间具有相同的数据）

​			      一致性（Consistency）是指多副本（Replications）问题中的数据一致性。可以分为强一致性与弱一致性。

​		          ① 强一致性

​				**简言之，在任意时刻，所有节点中的数据是一样的。**

​				例如，对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。

​				② 弱一致性

​				数据更新后，如果能容忍后续的访问**只能访问到部分**或者**全部访问不到**，则是弱一致性。

​				**最终一致性就属于弱一致性。**



**A (可用性Availability)**：指系统提供的服务必须一直处于可用的状态，每次只要收到用户的请求，服务器就必须给出响应。在合理的时间内返回合理的响应（不是错误和超时的响应）

​			**只有非故障节点才能满足业务正常；只有在合理的时间内，用户才能接受；只有返回合理的响应，用户才能接受。**



**P (网络分区容错性Partition tolerance)**：网络节点之间无法通信的情况下，节点被隔离，产生了网络分区， 整个系统仍然是可以保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。

​			**三种不能同时满足（很难做到），我们一般都选择其中的两种，CA或AP，其中p是必须保证的**

### 分布式事务解决方案

四种解决方案：

- XA(资源层面，也就是数据库)两段提交(低效率，强一致性)-分布式事务解决方案
- TCC(业务层面，也就是业务逻辑代码)三段提交(2段,高效率[不推荐(补偿代码)])
- 本地消息(MQ+Table)
- 事务消息(RocketMQ[alibaba])

**xa和tcc的异同**

xa和tcc都是要么都提交要么都不提交，xa锁的是数据库，tcc锁的是业务逻辑代码

### Seata

#### seata介绍

seata是阿里开源的一个分布式服务框架，

**有两个设计初衷**

l **对业务无侵入**：即减少技术架构上的微服务化所带来的分布式事务问题对业务的侵入

l **高性能**：减少分布式事务解决方案所带来的性能消耗



**Seata**中有两种分布式事务实现方案，AT及TCC

l AT模式主要关注多 DB 访问的数据一致性，当然也包括多服务下的多 DB 数据访问一致性问题 2PC-改进

l TCC 模式主要关注业务拆分，在按照业务横向扩展资源时，解决微服务间调用的一致性问题



**AT模式（Automatic (Branch) Transaction Mode）**

* **TC(Transaction Coordinator)事务协调者**：steata充当协调者，**维护全局事务的运行状态**，负责协调并决定全局事务的提交或回滚。

- **TM(Transaction Manager)**: 相当于GlobalTransactional注解，控制全局事务的边界，负责开启一个全局事务，并最终发起**全局提交**或**全局回滚**的决议。

- **RM(Resource Manager)资源管理者**:@Transactional注解，负责本地事务的注册，本地事务状态的汇报(投票)，并且**负责本地事务的提交和回滚**。

![image-20210116151705114](typora-user-images\image-20210116151705114.png)

**下面是一个分布式事务在Seata中的执行流程：**

1)   TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID

2)   XID 在微服务调用链路的上下文中传播。

3)   RM 向 TC 注册分支事务，接着执行这个分支事务并提交（重点：RM在第一阶段就已经执行了本地事务的提交/回滚），最后将执行结果汇报给TC

4)   TM 根据 TC 中所有的分支事务的执行情况，发起全局提交或回滚决议。

5)   TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。

Seata 中有三大模块，分别是 TM、RM 和 TC。 其中 TM 和 RM 是作为 Seata 的客户端与业务系统集成在一起，TC 作为 Seata 的服务端独立部署。

回滚使用**反向补偿机制：**在操作之前先记录一次，如果执行中有错误发生那么全部恢复到记录的状态