# JVM

## jvm的结构

![image-20210302094451372](typora-user-images\image-20210302094451372.png)

- jvm结构：
  1. 类加载器
  2. 执行引擎：负责解析代码指令，并提交给系统执行
  3. 本地方法接口：调用系统类库的一些接口
  4. 运行时数据区：
     1. 方法区：线程共享的，存类或者方法信息（属性 方法字节码 接口信息 构造函数 ）
     2. 堆(内存最大的一块区域)：new 一个对象，放在堆中的，OOM（堆溢出java.lang.OutOfMemoryError）
     3. java栈/jvm栈/栈内存：线程私有，随着线程创建而产生，随着线程的消失而消失。请求的处理，就是一个入栈出栈一个过程
     4. pc计数器/程序计数器：线程私有的，本质就是一个指针，指向下一行指令，空间非常小，不会发生OOM
     5. 本地方法栈：保存native方法的一个区域（**java做不到的方法都标为native方法，由c来做**）

> **执行流程，java文件转化成class文件，再通过类加载器加载到内存，通知执行引擎执行这些命令，执行引擎去找本地方法库（c编写的）**

### 类加载器

- 四种类加载器
  1. 启动类加载器（BootstrapClassLoader）：加载jre中的rt.jar，本身由C++或C实现
  2. 扩展类加载器（ExtClassLoader）：jre中其他的jar包（除rt.jar以外的）
  3. 应用类加载器（AppClassLoader）：classpath中引入jar包和项目class文件
  4. 自定义类加载（继承ClassLoader）
- 类加载过程遵循双亲委派原理：双亲委派（**就是先去找他的父级看看父级能不能执行，例如需要应用类加载器加载他会先找扩展类加载器，扩展类加载器会再去找启动类加载器，如果不能执行在依次返回给应用类加载器，应用类加载器能加载就加载，如果不能加载会报ClassNotFindException**）
  - 使用双亲委派目的：保证jvm稳定性及安全性

### 执行引擎

负责解析class执令，并执行指令

### 本地方法接口

为系统类库提供一些接口，以便native类型的方法的执行，一般操作硬件的方法才会编辑为native方法。

一般操作硬件的时候使用，比如操作打印机等，现在用的少了，可以通过网络进行控制

### 运行时数据区

#### 方法区

方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，**此区属于共享区间**。 

**静态变量+常量+类信息(构造方法/接口定义)+运行时常量池**存在方法区中

But

**实例变量(new的对象)存在堆内存**中,和方法区无关

#### 堆（重要HotSpot版本）

堆栈关系：注意这个是本地变量表

![image-20210302114154529](typora-user-images\image-20210302114154529.png)

> new的对象也会有一个指针指向方法区，这个方法区记录的是这个对象的class类型

**jdk7和以前：**

**Heap 堆**：一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存逻辑上分为三部分：

- **新生区(比例是：8:1:1)**
  - eden(8):存新创建的对象
  - 幸存区From(1)：存放幸存对象（经过minor GC依然存活的对象）
  - 幸存区To(to里面永远是空的1)
  - minorGC：回收eden和from把幸存对象存入to

新生区是对象的诞生、成长、消亡的区域，一个对象在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分： 伊甸区（Eden space）和幸存者区（Survivor pace） ，所有的对象都是在伊甸区被new出来的。幸存区有两个： 0区（Survivor 0 space）和1区（Survivor 1 space）。当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(**Minor GC**)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存 0区。若幸存 0区也满了，再对该区进行垃圾回收，然后移动到 1 区。那如果1 区也满了呢？再次垃圾回收，满足条件后再移动到养老区。若养老区也满了，那么这个时候将产生**MajorGC（FullGC）**，进行养老区的内存清理。<font color='red'>若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。</font>

> **新new一个对象进入eden当放满了以后会发生一次minor GC，minorGC后会有幸存对象，将幸存对象放入from中，然后再满的时候会进行一次minorGC，将eden和from进行清空，将存活对象放入TO中，最后将TO和From交换位置，依次循环，当经过15次minorGC后依然有对象存活，会将他放入养老区**

-  养老区 (堆中占比最大的一块)
  - 存储大对象和经过15次minorGC依然存活的对象
  - 当养老区的内存也满了的时候会进行两次FullGC后依然存不下会引发OOM，发生FUllGC之前会发生一次minorGC
  - 发生OOM(heap space)的原因
    - 堆内存不足
    - 创建了大量的大对象
- 永久区
  - 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。
  - 永久代引发OOM(PermGen space)的原因
    - 堆内存太小
    - 项目太大了
    - 项目中大量使用反射
    - 一个tomcat容器运行了多个项目
  - **永久代的更新迭代**
    - 1.6以前：有永久代，常量池就在永久代
    - 1.7：逐步去除永久代，常量池在堆中
    - 1.8：没有永久代，取而代之的是元数据空间，常量池在元空间

也称为：新生代（年轻代）、老年代、永久代（持久代）。

> **永久代本质就是方法区（或者使用永久代实现了方法区）**

实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，**虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。**

​		对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代(Parmanent Gen)” ，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区(相当于是一个接口interface)的一个实现，**jdk1.7的版本中，已经将原本放在永久代的字符串常量池移走。**

​		常量池（Constant Pool）是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，这部分内容将在类加载后进入方法区的运行时常量池中存放。



#### java栈/jvm栈/栈内存

**特点**：先进后出，线程私有的，随着线程的创建而产生，随着线程的结束而消亡

不需要垃圾回收，不会产生oom

可能会引发StackVoerFlowError（栈内存溢出），通常出现在递归调用中

**栈的基本单元是栈帧，栈帧由三部分组成：**

- 本地变量表：8种基本数据类型的数据和对象的引用地址
- 栈操作：出入栈的操作（父栈子栈）
- 栈帧数据：指向一些方法的具体信息

#### pc计数器/程序计数器

本质是一个指针，指向下一行要执行的指令或者是二进制字节码、java代码

#### 本地方法栈

保存native方法的一块区域

## 堆参数调优

![image-20210302143004506](typora-user-images\image-20210302143004506.png)

![image-20210302143014675](typora-user-images\image-20210302143014675.png)

### 常用JVM参数

| 参数                | 备注                                                   |
| ------------------- | ------------------------------------------------------ |
| -Xms                | 初始堆大小。只要启动，就占用的堆大小，默认是内存的1/64 |
| -Xmx                | 最大堆大小。默认是内存的1/4                            |
| -Xmn                | 新生区堆大小                                           |
| -XX:+PrintGCDetails | 输出详细的GC处理日志                                   |

### 分析工具

- MAT是eclipse使用的一个插件
- idea使用jdk自带的
  - 添加两个参数-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\自定义文件夹名称
  - 在jdk安装的bin包里面找到**jvisualvm.exe**
  - 在**jvisualvm.exe**中添加刚才生成的文件

### 常见的几个查看命令

- jps -l          查看java应用的进程号
- jinfo -flags 进程号     查看已设置的jvm参数
- jstat -gc 进程号           查看GC的统计信息

## GC垃圾回收

### 如何判定垃圾

#### 两种判定垃圾的算法：

##### **引用计数器算法(java已经放弃了该算法)**

- 优点：简单，高效，现在的objective-c、python等用的就是这种算法。
- 缺点：当两个对象相互引用会导致内存泄漏，需要额外的计数器，占用资源

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

##### **可达性分析算法(目前java使用的算法)**

从GCRoot对象来寻找引用，如果对象不能从GCRoot对象可达，经过两次标记后，这个对象就会被打成垃圾对象

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

![image-20210302154218079](typora-user-images\image-20210302154218079.png)

- 在Java语言中，可以作为GC Roots的对象包括下面几种：

  - 虚拟机栈（栈帧中的本地变量表）中的引用对象。
  - 方法区中的类静态属性引用的对象。
  - 方法区中的常量引用的对象。 
  - 本地方法栈中JNI（Native方法）的引用对象

  **真正标记一位对象为可回收状态至少要标记两次。(第一次遍历出垃圾对象，第二次清除)**

  

#### 四种引用

- 强应用：new User() ，就是强引用，平时new 的对象都是强引用，只要可以从GCRooot有引用可达
- 软引用: new SoftReference(new User())，一旦要发生OOM就会被回收。通常在缓存中使用
- 弱引用：new WeakReference(new User())，一旦发生GC就会被垃圾回收
- 虚引用：new PhantonReference(new User())，虚引用一旦创建就会被回收

> **判定是否是一个垃圾要结合可达性分析算法和四种引用**

### 怎么回收垃圾

> **次数上会频繁的回收新生代（使用复制算法），较少回收养老代（使用标记清除和标记整理），基本不回收永久代**

#### 复制算法

该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。

![image-20210302154218079](typora-user-images\gc_copying.gif)

- 优点：
  - 不会产生内存碎片
  - 实现简单
  - 内存连续
- 缺点：
  - 浪费一半内存
  - 对象存货比较高的情况下需要复制大量的对象，并且需要重置对象的指针，效率不高

#### 标记清除算法

![image-20210302154218079](typora-user-images\mark_sweep.gif)

“标记-清除”(Mark Sweep)算法是几种GC算法中最基础的算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。正如名字一样，算法分为2个阶段：

1. 标记阶段：遍历出所有的对象，标记出存活的对象和垃圾对象，使用的标记算法均为**可达性分析算法**。
2. 清楚阶段：遍历所有对象，清除第一次标记的所有垃圾对象。

- 优点：
  - 效率相对整理算法较高
- 缺点：
  - 会产生大量的内存碎片
  - 要经过两次遍历，效率不高

#### 标记整理算法

标记-整理法是标记-清除法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是通过**所有存活对像都向一端移动，然后直接清除边界以外的内存。**

![image-20210302154218079](typora-user-images\mark_compact.gif)

桶标记清除算法相同分为两个阶段：

1. 标记阶段：遍历所有对象，标记出存活对象和垃圾对象
2. 整理阶段：所有存活对象像一端移动，然后清除第一次标记的所有垃圾对象

- 优点：
  - 避免内存碎片
- 缺点：
  - 效率最低

#### 分代回收算法

jvm中只能扬长避短：

- 从效率上讲：复制算法 》 标记清楚 》 标记整理
- 从内存利用率： 标记整理算法 》 标记清楚 》 复制算法
- 内存连续度： 标记整理算法 = 复制算法 》 标记清除算法

> **年轻代：对象存活率不高，频繁的垃圾回收，适合使用复制算法**
>
> **老年代：对象存活率较高，选择标记清除或者标记整理算法**

## 垃圾回收器

**垃圾回收器新生代和老年代结合对比图**

![image-20210303091640164](typora-user-images\image-20210303091640164.png)

垃圾回收器的最终目标是高吞吐，低停顿

### Serial/Serial Old

Serial：是一个串行的垃圾回收器，会导致STW(stop the world)，单线程不可并发，使用复制算法

Serial Old：是serial的老年代版本，使用标记整理算法

### ParNew/Serial Old

parNew：是Serial多线程版本的一个垃圾回收器，多线程，不可并发，使用复制算法

### Parallel/Parallel Old

jdk1.6出现的

Parallel：是Serial多线程版本的一个垃圾回收器，多线程，不可并发，使用复制算法

Parallel Old：老年代使用标记整理算法

### ParNew/CMS（重要）

追求低停顿时间，他是一个老年代回收器

他将垃圾回收分为四个阶段：

1. 初始标记:单线程，会出现短暂的STW，只标记GCRoot对象或者GCRoot可直达的对象
2. 并发标记：多线程，可以和用户请求同时处理，一边处理请求一边标记第一次没标记的对象
3. 重新标记：会产生短暂STW，多线程标记，标记并发标记阶段没有标记到的对象
4. 并发清除：执行清除，不会产生STW

- 优点：
  - 低停顿
  - 提供了一些参数，能够弥补缺点
    - `-XX:+UseConcMarkSweepGC` 使用CMS收集器
    - `-XX:+ UseCMSCompactAtFullCollection` Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长
    - `-XX:+CMSFullGCsBeforeCompaction` 设置进行几次Full GC后，进行一次碎片整理
    - `-XX:ParallelCMSThreads` 设定CMS的线程数量（一般情况约等于可用CPU数量）
- 缺点：
  - 在并发阶段会影响系统的吞吐量
  - 会产生内存碎片

### G1（重要，既可以作为新生代，也可以作为老年代）

G1收集器是基于标记整理算法实现的，不会产生空间碎片，可以精确地控制停顿，将堆划分为多个大小固定的独立区域，并跟踪这些区域的垃圾堆积程度，**在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域（Garbage First）**。

**G1垃圾回收站的特点：**

1. 并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。

2. 分代收集：分代概念在G1中依然得以保留。虽然G1可以不需要其它收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。也就是说G1可以自己管理新生代和老年代了。(**他能判断你收集的部分，判断使用复制算法还是标记整理算法**)

3. 空间整合：由于G1使用了独立区域（Region）概念，G1从整体来看是基于“标记-整理”算法实现收集，从局部（两个Region）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片。

4. 可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用这明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

**堆不再是连续的内存空间了，它将内存分成大小相等的不连续的区域**

![image-20210303102310802](typora-user-images\image-20210303102310802.png)

> e：伊甸
>
> s：幸存区
>
> o：养老区
>
> h：大对象(超过Region一般区域)

四个阶段：

1. 初始标记：单线程，会出现短暂的STW，只标记GCRoot对象或者GCRoot可直达的对象
2. 并发标记：从GC Roots开始对堆中对象进行可达性分析，找出存活对象，这一阶段耗时较长但能与用户线程并发运行。
3. 最终标记：整理垃圾率，同时对没有标记的对象进行标记，这阶段需要停顿线程，但可并行执行
4. 筛选回收：垃圾率高的优先回收

### 垃圾回收器选择策略

![image-20210303093003897](typora-user-images\image-20210303093003897.png)

