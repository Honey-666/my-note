# 项目笔记3_13

## 异步编排(ComplatableFuture)

JDK1.8在juc包中提供的

特点：可以进行异步编排，和非阻塞的方式获取返回结果

本质也是一个Future，实现类Future接口

![image-20210324091202669](typora-user-images\image-20210324091202669.png)

### completableFuture方法

#### 四个静态方法创建异步操作

- runAsync(有不带线程池和带线程池重载的两个) ： 方法不支持 返回值

- supplyAsync(有不带线程池和带线程池重载的两个)  ： 可以支持返回值

#### 计算完成时回调

- whenComplete：只能获取上个任务的返回结果集
- whenCompleteAsync(有不带线程池和带线程池重载的两个) ：既可以获取上个任务的返回结果，还可以获取上个任务的异常信息
- exceptionally：只能处理上个任务的异常信息

#### 线程串行化方法(分为三组每组都有异步同步，有线程池无线程池)

- thenApply：可以获取上个任务的返回结果，并且可以给下个任务返回自己的结果
- thenApplyAsync(有不带线程池和带线程池重载的两个)



- thenAccept：只接收上个任务的结果，没有自己的返回结果
- thenAcceptAsync(有不带线程池和带线程池重载的两个)



- thenRun：既不获取上个任务的返回结果，也没有自己的返回结果
- thenRunAsync(有不带线程池和带线程池重载的两个)

#### 组合方法

- allOf：所有方法都执行完
  - CompletableFuture.allOf(要执行的所有future).join;

- anyOf：只要有一个执行完

> **总结：所有run的方法没有返回结果集，所有带supply的方法都有返回结果集，所有带apply的方法都有参数都有返回结果集，所有带有accept的方法都有参数，没有自己的返回结果集**

## 页面静态化

#### 和缓存的区别

1. 保存位置不同：页面静态化是保存在硬盘上的，缓存是保存在内存的
2. 页面静态化利用了静态页面的访问速度远远大于动态页面的访问速度，缓存利用了内存的访问速度，远远大于硬盘的访问速度
3. 使用场景不同：页面静态化适合大数据量，缓存不太适合海量数据(放在内存的，内存有限)
4. 使用场景不同：页面静态化适合数据变化频率低的，redis适合频率高的

#### 实现

> **页面静态化要基于模板引擎来实现**

注入thymeleafEngine，使用他的process方法

process方法有三个参数：

- 模板名称
- 上下文：里面包含模型数据
- writer：输出目的地的流

## 单点登录

**SSO：**Single Sign on 单点登录

#### cookie、session、token、jsessionId

- cookie：浏览器端的文本域
- session：服务器端的文本域，可以保存登录状态
- token：令牌，用户的唯一标识，一般被保存到cookie和local storage中
- jsessionId、jwt、uuid都被用作唯一标识



#### cookie的作用域

- 父域名不能操作子域名的cookie信息
- 子域名可以任意操作父域名的cookie信息
- 兄弟之间也不能相互操作cookie信息

> **cookie的默认作用域是当前域名**
>
> **一般我们都把cookie放到一级域名中**

#### cookie的作用路径

- 作用路径和作用域的相同，父不能操作子，箱底之间不能相互操作，子能操作父，**一般我们都设置为/**





- **有状态登录：**服务器端需要保存用户的登录信息(session)
  - 缺点：增加服务器端的存储压力； 无法做到水平扩展(服务的拆分)； 无法做到服务的伸缩(一个微服务多加了几台服务器) ;     多次访问必须访问同一台服务
  - 解决：session共享或者redis
- **无状态登录(jwt)：**服务器端不需要保存用户的登录信息，要求请求必须携带子描述信息
  - 优点：减少服务器存储的压力，可以做到服务的水平扩展一级服务器的任意伸缩；任意多次访问可以访问不同的服务器
  - 缺点：一旦颁发无法收回
- **注意：**防止jwt的伪造和盗用