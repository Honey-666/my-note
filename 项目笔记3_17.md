# 项目笔记3_17

**如何保证订单的幂等性：**当打开订单页时生成一个orderToken，并将这个orderToken缓存到redis中，如果redis中有，表示可以提交订单，提交完订单，将redis中的orderToken删除，当下次再去提交发现redis中没有，就不让用户提交

> **orderToken：唯一标识**



自定义分布式id，可以使用用户id+时间戳的方式(**缺点：**长度不同)



手机号+毫秒值(**缺点：**长度太长)



提交订单要注意两个问题：**防重和验价**

只要总价不变就可以



**提交订单流程：**

1. 防重(使用Lua脚本保证原子性)：查看redis中的orderToken存不存在，存在没有提交过，不存在，已提交
2. 验总价：页面上的价格和数据库的实时总价
3. 验库存立马锁库存：还要保证原子性(会有分布式事务问题，使用@tranaltion注解)
   - 传入一个封装的vo类集合，返回也是这个集合，这个vo类中包含五个字段，skuid，数量，布尔类型的锁定状态，锁定成功时锁定仓库的id(方便后续解锁)，orderToken
   - 遍历这个集合，使用redisson分布式锁保证原子性，进行验库存并锁库存
   - 验库存的本质就是查询
   - 锁库存的本质就是对锁定库存字段进行更新
   - 通过stream流的anyMatch方法判断有没有锁定失败的，如果有那么通过stream的filter方法过滤出锁定成功的集合，对这些商品进行解锁
   - 最后，为了方便将来超时未支付的时候解锁库存或者支付成功减库存，需要把订单对应的锁定库存信息缓存到redis中，以订单编号作为key，锁定集合作为value
4. 创建订单(会有分布式事务问题，使用@tranaltion注解)**主要事务在第四步**，存在两种情况，一种是创建失败，另一种响应失败，标记为无效订单，这两种都要发送消息给oms更新为无效订单，然后oms在发送消息给wms解锁库存
5. 删除购物车中对应的记录