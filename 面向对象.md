# 面向对象

## 1.类和对象的关系

* 类是对象的模版,抽象
* 对象是类的实例,实体

## 2.类的设计

* 在类中编写类的属性和行为

  ```java
  public class Student {
      String name;
      int age;
      
      void study(){}
  }
  ```

* 在类中添加封装的思想
* 在类中添加类的第三个成员:构造器
* 在类中添加静态的概念
* 在类中添加继承的思想
* 因为在类中添加的继承思想,会存在三点安全隐患,在类中添加抽象的概念
* 在类中添加接口的概念
* 在类中添加第四个成员(构造代码块)和第五个成员(静态代码块)

## 3.对象的使用

* 创建对象

  ```java
  类名 对象名 = new 类名();
  ```

* 通过对象调用属性和行为

  ```
  对象名.变量名;
  对象名.方法名;
  ```

## 4.局部变量和实例变量的区别

* 代码中的位置不同
  * 实例变量:类中方法外
  * 局部变量:方法内部或者方法的声明上
* 内存中的位置不同
  * 实例变量:堆内存
  * 局部变量:栈内存
* 默认值不同
  * 实例变量:有默认值
  * 局部变量:没有默认值
* 代码中的作用域不同
  * 实例变量:从定义的那一行开始,到所属类结束
  * 局部变量:从定义的那一行开始,到所属方法结束
* 内存中的生命周期不同
  * 实例变量:随着对象的创建而加载,随着对象的消亡而消失
  * 局部变量:随着方法的调用而加载,随着方法的出栈而消失

## 5.封装

* 封装思想体现:3个权限修饰符和4个访问权限
* 4种访问权限从小到大顺序
  * private
  * 缺省
  * protected
  * public
* 4种访问权限作用域访问
  * private在本类中有效
  * 缺省在当前包内有效
  * protected在不同包且有子父类继承关系中有效
  * public在同一个项目下有效
* **类、接口、成员变量、成员方法、构造器、自定义变量、局部变量常用的权限修饰符**
* 类,接口:public
* 成员变量:private
* 成员方法:public
* 构造器:public或者private
* 自定义常量:public
* 局部变量:缺省

## 6.private关键字

* 在实例变量的前面添加private关键字
* 每一个被private修饰的变量对外提供一对的公共的访问方式

## 7.构造器(构造方法)

* 作用
  * 初始化对象
  * 如果是有参的构造器,给对象的属性进行赋值
* 特点:
  * 构造器名字和类名必须相同
  * 构造器没有返回值类型,而且连void都不能有
  * 构造器可以进行重载
  * 当一个类没有任何构造器时,JVM自动提供一个默认无参的构造器,用来初始化对象

## 8.JavaBean标准类

* JavaBean:程序员定义类的一种规范或者标准
* 规范
  * 一个.java文件只允许定义一个类或者接口
  * 必须有
    * 私有化成员变量
    * set和get公共访问方式
    * 无参构造器
  * 可以有
    * 有参的构造器
    * 构造代码块
    * 静态代码块

## 9.static关键字

* 被static关键字修饰属性和行为不在属于对象,而且属于类,会被这个类创建的所有对象所共享
* 被static关键字修饰的成员在内存中只加载唯一的一次
* 在静态方法中不可以调用非静态成员
* 在静态方法中不可以使用this和super

## 10.继承

* 格式

  ```java
  public class 父类类名 {}
  
  public class 子类类名 extends 父类类名 {}
  ```

### 继承特点(证明一句话:子类继承父类所有属性和行为)

* 私有的成员
  * 子类可以继承父类的私有成员,不可以直接访问,需要通过set和get进行访问
* 静态的成员
  * 子类可以继承父类的静态成员
* 同名的实例变量
  * 可以使用this和super关键字进行区分
* 同名的实例方法
  * 可以使用this和super关键字进行区分
  * 方法的重写:在子父类继承关系中或者接口实现关系中,出现了方法名相同,形参列表相同的项目
    * 子父类中的方法名必须相同
    * 子父类中的方法形参列表必须相同
    * 子类的权限修饰符必须大于等于父类的方法权限修饰符
    * 返回值类型
      * 当返回值类型是void时,子类和父类返回值类型必须相同
      * 当返回值类型是基本数据类型时,子类和父类返回值类型必须相同
      * 当返回值类型时引用数据类型时(类),子类的返回值类型可以和父类的返回值类型相同或者是父类返回值类型的子类(多态)
* 构造器
  * 在初始化子类之前先初始化父类对象
  * 当子类构造器中没有任何的this()或者super(),JVM自动提供一个默认无参的super(),用来初始化父类对象

### 继承的注意事项:

* 在Java语言中,只支持单继承,不支持多继承
* 支持多层继承
* 一个类不可以同时拥有多个直接父类,但是一个类可以有多个子类

## 11.super和this关键字

### this关键字

* 应用场景1:子类的实例方法中
  * 含义:哪个对象调用了含有this的实例方法,这个this关键字就代表哪个对象
  * 应用:
    * 区别同名的实例变量和局部变量

* 应用场景2:子类的构造器中
  * 含义:调用本类中其他的构造器
  * 应用:
    * 当自己构造器无法完成相应功能时,需要通过this()调用其他的构造器进行完成

### super关键字

* 应用场景1:子类的实例方法中
  * 含义:哪个对象调用了含有super的实例方法,这个super关键字就代表这个类的父类对象
  * 应用:
    * 用来区别父类和子类同名的实例变量
    * 用来区别父类和子类同名的实例方法
* 应用场景2:子类的构造器中
  * 含义:调用父类的构造器,用来初始化父类的成员

### this和super关键字注意事项:

* this和super关键字不能应用在静态方法中
* 在子类的构造器this()和super()不能同时使用
* 在子类的构造器中无论this()还是super()必须放在构造器的第一行

## 12.Object类

* Object类是所有的类的父类,在Java中所有对象(数组)可以直接使用Object类中方法,所有的接口都继承Object类的接口形式
* toString()
  * 在进行打印对象的名字,默认调用对象的toString()
* equals()
  * ==和equals()区别:
    * == :可以比较基本数据,也可以比较引用数据类型
      * 如果比较的是基本数据类型的时候,比较的是基本数据类型的数据值
      * 如果比较的是引用数据类型的时候,比较的是引用数据类型的内存地址值
    * equals():只能比较引用数据类型
      * 比较的是引用数据类型的时候,比较的是引用数据类型的内存地址值
      * 如果当前类重写了Object的equals(),需要按照重写后的规则进行比较

## 13.抽象

### 抽象的由来

- 通过继承关系抽取的父类是多个子类共有的属性和行为，理论上不应该被实例化；（理想化：不能实例化）
- 通过继承关系抽取的父类的行为方法，需要被子类重写时，写完父类后很容易忘记；（理想化：子类没有重写父类的行为方法时，编译报错）
- 通过继承关系抽取的父类的行为方法，因为需要被子类重写时，所有方法实体比较多余；（理想化：不要写方法实体，交给子类完成，提高开发效率）

### 抽象类

```java
public abstract class 类名字 { 
  
}
```

## 14.final关键字

* 含义:最终的,不可改变的
* 被final修饰的类,不能被继承
* 被final修饰的方法,不可以被重写
* 被final修饰的变量,只允许被赋值一次
  * 如果修饰的变量是局部变量,只允许被赋值一次,可以先定义后赋值
  * 如果修饰的变量是实例变量,要是先定义后赋值的话,需要在这个类所有的构造器中给这个自定义常量进行赋值
  * 如果修饰的变量是静态变量,要是先定义后赋值的话,需要在静态代码块中给这个自定义常量进行赋值

## 15.接口

* 接口:定义类的一组方法的集合和一组标准数据

* 成员:

  * 自定义常量

    ```java
    [public] [static] [final] 数据类型 常量名 = 常量值;
    ```

  * 抽象方法

    ```java
    [public] [abstract] 返回值类型 抽象方法名 ();
    ```

  * 默认方法(JDK8.0)

    ```java
    [public] default 返回值类型 方法名 () {}
    
    注意事项:
    	1.当一个类,继承一个父类并实现接口时,当父类和接口中有同名的方法时,调用子类这个方法时,执行的是父类的方法
        2.当一个类实现多个接口时,多个接口中含有同名的默认方法,实现类需要重写默认方法
    ```

  * 静态方法(JDK8.0)

    ```java
    [public] static 返回值类型 方法名 () {}
    ```

  * 私有方法(JDK9.0)

    ```java
    private 返回值类型 方法名 () {}
    
    private static 返回值类型 方法名 () {}
    ```

### 类和接口的关系:

* 类和类的关系:单继承
* 类和接口的关系:多实现
* 接口和接口的关系:多继承

## 16.多态

* 多态:事物多种形态
* 前提条件:
  * 要有子父类继承关系或者实现类接口的实现关系
  * 要有方法的重写(没有方法重写的多态编译不报错,但这样的多态没有任何意义)
  * 父类的引用指向子类对象(父new子)或者接口的引用指向实现类对象(接口new实现类)
* 多态的特点:
  * 通过多态调用方法时,先看父类中是否有这个方法,如果有,执行子类重写后的方法;如果没有,编译报错
* 多态的好处
  * 将父类或者父接口作为方法的形参,在使用时只需要传递给这个方法参数的子类对象或者实现类对象即可
  * 多态数组
* 多态的弊端
  * 通过多态调用方法时,对象无法调用子类特有的方法
  * 通过引用数据类型的转换
    * 向上转型(多态)
    * 向下转型(强转)

* instanceof关键字

## 17.匿名内部类

* 基础的使用接口的步骤

  ```java
  // 1.定义接口
  public interface 接口名 {
      抽象方法;
  }
  
  // 2.定义接口的实现类
  public class 实现类名 implements 接口名 {
      // 3.重写接口中的抽象方法
  }
  
  // 4.在测试类中创建实现类对象
  public class Test {
      public static void main (String[] args) {
          接口名 实现类对象名 = new 实现类名();
          //5.调用重写的抽象方法
          实现类对象名.抽象方法名();
      }
  }
  ```

* 学习匿名内部类目的:

  * 简化上述过程
  * 为了学习Lambda表达式前提

* 用匿名内部类的格式进行简化

  ```java
  // 1.定义接口
  public interface 接口名 {
      抽象方法;
  }
  
  // 2.在测试类中用匿名内部类的方式创建实现类对象
  public class Test {
      public static void main (String[] args) {
          接口名 实现类对象名 = new 接口名(){
      		// 3.重写接口中的抽象方法
  		};
          
          //4.调用重写的抽象方法
          实现类对象名.抽象方法名();
      }
  }
  ```

# 学习方法

* 12点不要睡觉,2点不管学习到什么程度都必须睡觉
* 30%复习
* 30%预习
  * 不要看视频
  * 一定敲
  * 这个知识点是什么
  * 这个知识点有什么特点
  * 这个知识点怎么用
  * 这个知识点什么时候去用 
* 40%上课认真听讲

