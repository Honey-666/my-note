# 项目笔记3_4

**事务管理器的顶层接口：**PlatormTransactionManager

**传播行为：**一个具有事务的service方法，调用了另一个具有事务的方法，两个service的方法事务之间的影响



**七中传播行为：**

**第一组：**

- REQUIRED：两个service方法使用同一个事务，如果a没事务，那么创建一个事务
- SUPPORTS：b支持a的事务，如果a没有事务，则b也以非事务方式运行，如果有都有，如果没有都没有
- MANDATORY：a如果有事务，b加入事务，如果a没有事务，则b抛出异常

**第二组：**

- REQUIRES_NEW：如果a有事务，b会先将a的挂起，先执行自己的
- NOT_SUPPORTED：如果a有事务，将事务挂起，a和b以非事务方式运行
- NEVER：a有事务抛出异常

**第三组：**

- NESTED：嵌套事务

#### **事务的回滚策略**

所有的受检异常(编译时异常)，都不回滚，所有的不受检异常(运行时异常)都回滚

- rollbackFor，设置那些异常回滚(设置的是.class)

- noroolbackFor，设置哪些异常不会滚(设置的是.class)
- rollbackForClassName设置那些异常回滚(设置的是异常名)

- noRollbackForClassName，设置哪些异常不会滚(设置的是异常名)

#### 超时事务

timeout设置超时时间，单位是秒

默认是不超时

#### 只读事务

readOnly设置只读

### 分布式事务

逻辑上的一组操作，组成这组操作的各个逻辑单元，在不同的服务甚至是不同的服务器上，保证要成功都成功，要失败都失败

**分布式使用场景：**

1. 不同服务，不同数据库
2. 相同服务，不同数据库
3. 不同服务，相同数据库

**导致分布式事务的问题原因：**

1. 程序异常
2. 网络传输异常
3. 服务器宕机

**理论：**

- CAP
  - C：consistency 一致性
  - A：Availability可用性，挂掉一台服务器依然可用
  - P：Partition tolerance 分区容错性(分区容忍性)，服务之间的通信可能失败，是无法避免的

> **P是不可避免的，C和A是相互矛盾的，要么保AP，要么保CP，一般我们保AP**

- BaSE
  - Ba：基本可用，保证核心可用
  - S：Soft status 软状态(中间状态)，允许一定时间内的不一致
  - E：最终一致

#### 解决方案

- 2PC两阶段提交(先预提交，在提交)
  - P：Prepare
  - C：Commit

> **数据库有一个规范叫XA协议：针对两阶段提交的一个规范协议，但是开源免费的数据库支持的不好**
>
> **要经过多次网络传输，性能不高，导致锁定资源时间变长，阻塞很多请求**
>
> **NoSQL不支持XA协议**

- TCC补偿性事务(编程式事务)
  - T：Try，检查资源，并锁定资源
  - C：Confirm，执行业务逻辑
  - C：Cancel，取消事务或是补偿事务
  - **缺点：**
    - 代码量大，会带来开发困难
    - 在业务逻辑复杂的情况下，很难把握补偿点
- MQ最终一直性

性能最高的是MQ最终一致性(并发量高用)

一致性最高的是2PC(并发量不高用)

### Seata

**全局事务**

- 由一系列分支事务组成的

**分支事务**

- 分支事务就是本地事务(Transaction)

**TC/TM/RM**

- TC：Transaction Coordinator，事务协调器，控制全局事务的运行状态，并驱动全局事务的提交或者回滚
- TM：Transaction Manager，事务管理器，控制全局事务的边界，开启全局事务，并发起全局事务的提交或者回滚的协议
- RM：Resource Manager，资源管理器。控制分支事务，控制执行状态，并向TC汇报执行状态。接受TC的指令，最终执行事务的提交和回滚

![image-20210312111621680](typora-user-images\image-20210312111621680.png)

**事务流程/原理**

1. TM会向TC开启一个全局事务，TC创建全局事务，并生成一个唯一标识Xid
2. Xid会在微服务调用链路中进行传播
3. RM像TC注册分支事务，TC会把分支事务纳入到Xid对应的全局事务中去
4. TM像TC发起全局事务的提交或者回滚
5. TC命令RM最终执行事务的提交或者回滚

> **注意：使用seata的时候表都要有主键，库中都要有undo_log表**

### elasticsearch

**搜索：**根据用户输入的关键字检索出用户所需要的数据

**搜索引擎：**根据用户输入的关键字，结合一定策略或者是算法，检索出用户所需要的数据的一门技术

**倒排索引：**又称反向索引，分两部分组成

- 文档类表：存文档
- 倒排索引区域：存储关键字，通过关键字找到指定文档

**全文检索：**是一种需求

三者关系：全文检索是一种需求，倒排索引是一种实现原理，搜索引擎是具体实现

**常见的两个搜索引擎：**

lucene：搜索引擎的底层API，类似于servlet

1. elasticsearch:底层是lucene（类似于tomcat）
2. solr：底层是lucene（类似于tomcat）

#### elasticsearch中的概念回顾

es和数据库中的对应

| es            | 数据库       |
| ------------- | ------------ |
| indices索引库 | datasource库 |
| type类型      | table表      |
| document文档  | row行        |
| mapping映射   | schema约束   |
| field         | 数据库字段   |

