# HashMap扩容原理

1、首先判断是否是第一次添加元素，如果为第一次添加元素，计算这个元素的hash值并异或这个元素hash值右移16位  然后返回给h

创建Node数组，Node对象，判断这个数组等不等于null，第一次添加为null，然后判断这个数组的长度和临界值是否大于0，第一次添加不大于0    然后给这个数组初始化长度为16 ，临界值为16乘以加载因子（0.75）=12

2、第二次添加，计算这个hash值并异或这个元素hash值右移16位 然后返回给h  判断数组是否为null或者长度是不是0，不为null长度为16，然后（16-1）&一个h（二次hash值）算出这个要添加元素的位置，再看这个位置现在有没有元素，如果没有直接把要添加的元素放在这个位置上，元素++   元素个数++     然后在判断元素个数是否>12  如果不大于12就不对其进行扩容，如果大于12就对其进行扩容 判断当前数组长度是否大于1<<30  不大于     然后在判断当前数组左移一位是否小于1<<30 并且当前数组>=16 ，小于<<30大于16 然后对临界值进行左移一位，

​			如果有元素就判断要添加的这个元素和现在在这个位置上的元素的hash值是否相等，并且这两个元素的地址值是否一样（或者调用equlas方法看内容是否相等）如果相等就把原有位置上的元素给覆盖掉，如果不等就看他是不是红黑树，如果不是红黑树就做一个循环先判断原来在这个位置上的元素的下面是否为null，

​			如果为null直接添加在下面，然后判断链表的元素个数是否>=8-1，如果大于8-1在判断是否       小于<64如果小于64就对他进行扩容，如果大于64就变成红黑树结束循环，

​			如果不为null就判断这两个元素的hash值是否相等，并且这两个元素的地址值是否一样（或者调用equlas方法看内容是否相等如果相等就覆盖，如果相等跳出循环，再判断链表所在位置上的元素是否为空（肯定不为空），进入判断语句，将链表所在元素的value值赋值给一个变量，再将要添加的元素的value覆盖掉链表所在元素的value，return那个变量（就是将 被覆盖的value返回）；元素++   元素个数++     然后在判断元素个数是否>12  如果不大于12就不对其进行扩容，如果大于12就对其进行扩容 判断当前数组长度是否大于1<<30  不大于     然后在判断当前数组左移一位是否小于1<<30 并且当前数组>=16 ，小于<<30大于16 然后对临界值进行左移一位（也就是乘2）
